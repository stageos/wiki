```{r knitr_init, echo=FALSE, cache=FALSE}
library(knitr)
library(rmdformats)

## Global options
options(max.print="75")
opts_chunk$set(echo=TRUE,
               eval = TRUE,
               cache= FALSE,
               prompt= FALSE,
               tidy=TRUE,
               comment=NA,
               message=FALSE,
               warning=FALSE,
               dpi= 200, 
               dev = c('png','svg'),
               fig.path= 'figures/')
opts_knit$set(width= '100%' )
```

```{r echo = FALSE}
library(imager)
```


# Principes généraux

Le site StagOs vous permet de créer des projets sur lesquels vous pourrez le cas
échéant travailler à plusieurs, y compris pendant leurs phases d'exploitation et de
maintenance.

Nous vous créons automatiquement et dynamiquement le pipeline qui vous permettra
de gérer de bout en bout votre intégration continue et votre déploiement continu.

Une intelligence artificielle scrute vos sources lors de vos commits et en déduit
les composants à intégrer dans votre _pipeline_ puis déclenche celui-ci jusqu'à l'étape que 
vous avez déterminée, et ce le cas échéant jusqu'à la mise en exploitation automatisée
de votre application via des containers sécurisés et performants  (__Docker/Kubernetes__ )
exposés via _AWS_.

Le projet est abrité sous le Gitlab StageOS et nous vous proposons donc ici un petit 
mode d'emploi de celui-ci dans le contexte StageOs.

__Tips : pour agrandir une image de ce site, cliquez dessus !__


# S'identifier sous StageOS 

Il convient tout d'abord de faire un _sign up_, vous recevrez alors un mail de confirmation où il vous faudra cliquer pour revenir sur notre site.

A partir de là vous pourrez vous identifier et serez en mesure de créer vos projets.

```{r   sign_in, echo = FALSE, fig.cap = " écran d'identification"  }
img_from <- here::here("docs/images/sign_in.PNG")
plot(as.raster(load.image(img_from)))

```

 
A tout moment vous pouvez réinitialiser votre mot de passe ou en retrouver un au travers du lien _forgot your password?_ qui est diponible dans l'écra du _sign in_.


# Gérer mes projets


Après vous être identifié, vous avez accès à vos projets. Notez que ce cycle sera plus rapide lors de vos prochains accès à StageOS qui vous remettra automatiquement dans votre contexte via différents mécanismes, dont le mécanisme SSL (nous verrons plus loin comment et ou déclarer votre clé RSA).

## Créer un projet

Au départ, l'interface des projets est vide, et vous êtes incité à cliquer sur le __+__ bleu pour créer un nouveau projet.


```{r   my_project_empty, echo = FALSE, fig.cap = " création de projets"  }
img_from <- here::here("docs/images/my_project_empty.PNG")
plot(as.raster(load.image(img_from)))

```

Avant de créer un projet, vous pouvez créer un token, le copie et le conserver pour un usage futur. 
Nous verrons plus loin que cela vous permettra de cloner facilement d'autres dépots pour les insérer
dans votre projet.


```{r   my_token, echo = FALSE, fig.cap = " création d'un token"  }
img_from <- here::here("docs/images/my_token.PNG")
plot(as.raster(load.image(img_from)))

```


Il faut maintenant accéder à l'interface de création de projet. Soyez très attentif à la 
façon dont vous allez renseigner le nom du projet et les commentaires car cela
aidera vos collègues ou partenaires à mieux cerner l'objet de celui-ci.

Vous remarquerez que vous pouvez inviter d'autres personnes à participer au projet
avec divers rôles. A ce stade vous êtes encore seul et votre rôle est _mainteneur_ du projet,
ce qui vous donne tous les droits sur celui-ci.

```{r   create_project, echo = FALSE, fig.cap = " création de projets - détail"  }
img_from <- here::here("docs/images/create_project.PNG")
plot(as.raster(load.image(img_from)))

```


Après un petit temps d'attente votre projet est créé. Pour ce faire nous avons configuré
Gitlab avec vos crédentiels initiaux et créé les utilisateurs concernés que vous avez invité.
Ces utilisateurs hériteront des droits attachés à leur rôles respectifs. Typiquement
un développeur ne pourra pas administrer votre projet.


Nous avons créé un projet sous Gitlab, ce qui explique qu'il soit désigné par 
l'icône de ce produit.


```{r   my_projects, echo = FALSE, fig.cap = " mes projets"  }
img_from <- here::here("docs/images/my_projects.PNG")
plot(as.raster(load.image(img_from)))

```


Vous pouvez alors aller consulter la syntèse de votre projet en cliquant sur son icône.

Vous voici dans l'interface principale de StageOS : en "régime de croisière", il est possible
que celle-ci soit l'unique interface que vous utilisiez au quotidien. Nous verrons plus loin
que vous pourrez identifier les statut de tous les flux de travaux techniques générés par
StageOS pour faire parcourir à votre projet ses différentes étapes de construction et de
déploiement (du build au déploiement en passant par la qualité&test). 

Les __pipelines__ devops
sont en effet automatiquement mis en oeuvre au travers de l'analyse des éléments de votre __repository__ 
lors du __commit__. L'interface, vous permettra de vérifier l'avancement et l'état de leur exécution en quelques secondes.

Pour le moment, concentrons-nous sur la partie haute de l'interface.

```{r   project_interface, echo = FALSE, fig.cap = " Interface de gestion du projet"  }
img_from <- here::here("docs/images/project_interface.PNG")
plot(as.raster(load.image(img_from)))

```



Notez qu'à tout moment vous pouvez décider de rendre ce projet publique à la communauté
StageOS et/ou le rendre à nouveau privé via le switch _public/private_.

Vous constatez que votre  projet est affublé d'un mini identifiant interne à StageOs, un nombre (ici _565_ ), ne soyez pas étonné!

Vous n'avez pas encore de status sur vos Pipelines, puisque vous n'avez encore
rien produit ou cloné dans votre _repository_ Gitlab.

Vous pouvez maintenant cliquer vers l'url du Gitlab créé automatiquement pour vous, 
qui ressemble à cela :

      https://xxxx.stageos.io/first-project-565/first-project.git

**Attention** : StageOS gère votre sécurité, il vous demande donc de  vous _signer_ 
sur le repository au travers de son propre mécanisme ( Bouton _Stage OS_).


```{r   sign_with_stageos, echo = FALSE, fig.cap = " crédentiels automatiques vers votre repository"  }
img_from <- here::here("docs/images/sign_with_stageos.PNG")
plot(as.raster(load.image(img_from)))

```

Maintenant, laissez-vous faire et accédez à votre projet sous Gitlab.

Vous y êtes, force est de constater que c'est un peu vide et que personne ne vous
a encore mis d'étoile ni _forké_, mais maintenant tout est possible !


```{r   first_project, echo = FALSE, fig.cap = " mes projets"  }
img_from <- here::here("docs/images/first_project.PNG")
plot(as.raster(load.image(img_from)))

```

Pour être parfaitement opérationnel et sécurisé il vous faut __accepter__ au plus vite
de créer un couple de clé RSA (publiques et privées) pour mettre en place le mécanisme SSL pour gérer les habilitations entre vos espces de travail, à savoir un ou plusieurs matériels, et le Gitlab. Notez que vous pouvez introduire plusieurs clés et les détruire.

Sous la ligne de commande de votre machine Linux/MAC/Windows (ou via Putty ou Kitty sous Windows, en utilisant les mêmes paramètres) 
vous pouvez saisir, en y mettant votre propre adresse email:

```{bash, eval = FALSE}
ssh-keygen -o -t rsa -b 4096 -C "mon_adresse_mail@site.extension"
```

Il vous faut alors donner un nom de fichier ( __cela génèrera 2 fichiers__), Attention
identifiez bien le chemin des deux fichiers et conservez les bien à l'abris des regards !

```
Enter file in which to save the key (chemin ...) : 
```

Il est conseillé d'accepter de donner une _paraphrase_, une chaine de caractère
qui protège l'accès à vos clés.

Il vous suffira maintenant d'ouvir le fichier __clé publique__ et de couper/coller
la clé qui s'y trouve là où Gitlab vous le demande.


```{r   ssh_coller, echo = FALSE, fig.cap = " là où il faut coller sa clé publique"  }
img_from <- here::here("docs/images/ssh.PNG")
plot(as.raster(load.image(img_from)))

```

Voilà, après avoir cliqué sur _Add key_, vous avez fini la configuration minimale
de votre projet et vous êtes opérationnel !

## Détruire un projet

Soyez très prudent avec cette action __irréversible__. 

Il est évident que la plupart des développeurs travaillent sur un environnement local
et effectuent régulièrement un _push_ de leur environnement vers l'espace commun, ici le projet que 
vous venez de créer : ce qui crée une forme de sauvegarde locale de vos informations.
Pour autant, la destruction du projet vous fait perdre la traçabilité des mises à jours des
différents acteurs et des informations disponibles dans le _wiki_ du projet (entre autres).

Il est de toute façon de bonne pratique de cloner régulièrement votre projet afin 
de disposer de sauvegardes logiques de celui-ci ( via les mécanismes de Git qui sont documentés dans notre interface Gitlab).

Evidemment, pour sa part, StageOS a mis en place les mécanismes de sauvegarde 
indispensables pour préserver votre patrimoine applicatif.

Pour détruire un projet cliquer la croix ( _x_ ) rouge. Vous disposez alors d'une
dernière chance de retour arrière via le bouton _Cancel_.


```{r   delete_project, echo = FALSE, fig.cap = " destruction projet", fig.asp = 0.4 }
img_from <- here::here("docs/images/delete_project.PNG")
plot(as.raster(load.image(img_from)))

```

# Hello world !

## Préparer une application pour votre Hello world

Pour construire et déployer une application avec StageOS ... il ne  vous faut qu'une chose : 
une application à construire et déployer !

Nous supposons ici que vous disposiez d'une telle application  à déployer dans un langage et dans un contexte de dépendances
techniques que nous supportons déjà (consultez la liste à jour en fin de tutoriel).


|
|



Typiquement cette application se caractérise de la façon suivante :

* elle fait quelque chose, par exemple elle expose sur le web une page Html où il est écrit "Hello world" ou elle expose une API RESTFUL qui renvoie "Hello world". Elle peut évidemment être infiniment plus complexe et riche.
* __Optionnellement__ :
    * pour la construire vous avez utilisé un ou des gestionnaires de packages et de dépendances, et il existe quelquepart un ou plusieurs  fichiers (.json, .yaml ...) qui décrivent ces relations : __nous en tiendrons compte__.
    * vos fichiers sont répartis dans une arborescence de votre choix qui comporte des sources, mais aussi des fichiers de configuration et des définitions de tests unitaires : __nous scannerons cette arborescence__.
    * vous utilisez des outils pour gérer vos tests unitaires et/ou divers middlewares : __nous traiterons automatiquement ces outils__ si nous les supportons déjà (consultez la liste à jour en fin de tutoriel).
    * certaines dépendances ne font pas l'objet d'une déclaration externe, mais apparaissent dans le code (import d'un package ...) : __nous analyserons votre code__ pour construire l'application avec des versions cohérentes de ces dépendances.
    * __vous exigez__ que nous construisions l'application avec une dépendance donnée, une version d'interpréteur donnée ... : nous vous fournissons un fichier de configuration (optionnel) pour vous permettre de stipuler cette contrainte et __nous nous alignerons sur cette exigence spécifique__. Nous utiliserons alors cette exigence spécifique pour redéfinir toutes les autres dépendances en fonction de celle-ci.


|
|

    
    
Nous avons construit un repository pour votre projet abrité dans notre infrastructre StageOs. Nous nous appuyons sur les __commit__ que vous ferez sur ce repository pour déclencher nos processus d'analyse, d'intelligence artificielle, de construction, test et déploiement de votre application. Il vous est possible de l'alimenter de plusieurs manières :

1. intervention directe dans le Gitlab mis à votre disposition : dépot manuel de vos sources et commit dans la branche master pour lancer nos processus automatiques.
2. utilisation de votre Git Local et __clone__ et __push__ de votre repository Git local vers notre infrastructure en utilisant le token mis à votre disposition vu plus haut (vous pouvez le régénérer à tout moment)
3. utilisation d'un repository distant, Gitub ou Gitlab par exemple ( deux options s'offrent alors à vous : passer par votre repo local où __clone__ et __push__ direct en utilisant les mécanismes que nous mettons à votre disposition via le token).


|
|

### cas N°1 : créer votre code dans le Gitlab de votre projet

Imaginons que vos vouliez créer l'application Python/Flask suivante :

```{python , eval=FALSE }
from flask import Flask

app = Flask(__name__)

@app.route("/")
def index():
    return "Hello World from Flask!"

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000)
```

<br>
<br>

L'objet de cette application est d'exposer au monde votre "Hello world".
Dans notre Gitlab, vous pouvez créer un fichier (le cas échéant en coupiant/collant le code, évidemmment en modde __Edit__ :

<br>


```{r   add_new_file, echo = FALSE, fig.cap = " Création d'un fichier source" }
img_from <- here::here("docs/images/add_new_file.PNG")
plot(as.raster(load.image(img_from)))

```

<br>
<br>

Vous devez alors effectuer un _commit_ sur la branche _master_, ce qui lancera notre IA :

<br>


```{r   commit, echo = FALSE, fig.cap = " Commit sur la branche master" }
img_from <- here::here("docs/images/commit.PNG")
plot(as.raster(load.image(img_from)))

```

<br>

Vous retrouvez le statut de votre _pipeline_ dans l'interface principale :

<br>

```{r   build_config_running, echo = FALSE, fig.cap = " Commit sur la branche master" }
img_from <- here::here("docs/images/build_config_running.PNG")
plot(as.raster(load.image(img_from)))

```

<br>

Si vous le voulez vous pouvez retrouver la liste de toutes vos activités dans le Gitlab.

```{r   activity, echo = FALSE, fig.cap = " Commit sur la branche master" }
img_from <- here::here("docs/images/activity.PNG")
plot(as.raster(load.image(img_from)))

```

Mai, à l'usage on remarque que la plupart des utilisateurs préfèrent utiliser la vue
_pipeline_ de notre interface principale qui ne présente aucune information superflue à priori.



|
|

### cas N°2 : git local --> StageOS

Si l'on se place dans le deuxième cas (le plus courant) il vous suffit de :

1. générer un token (voir plus haut, un click dans notre interface) et de le conserver
2. identifier l'uri du Gitlab que nous vous avons créé pour votre projet et d'être loggé via StagOS
3. Pour initier la démarche, cloner ce repository vers votre git local, par exemple en utilisant votre CLI (Gitbash ...) :

    * positionnez-vous dans le folder cible (cd ...)
    * créez une variable d'environnement pour le token :
    
    ```
    export STAGEOS_TOKEN = _coller_ici_votre_token_
    ```
    
    * cloner le repository StageOS : 
    
    ```
    git clone https://MyToken:$STAGEOS_TOKEN@uri_de_votre_gitlab_stageOS votre_nouveau_repo_local
    ```
    
    * ne pas paniquer s'il vous dit qu'il est vide, la première fois ... c'est vrai !
    
4. Maintenant il vous suffit de copier votre aborescence projet avec vos fichiers source dans votre repo local :
    
    * copier ce qui vous est utile dans le folder de votre repo
    * verifier que votre .gitignore exclut les fichier inutiles
    * mettez l'ensemble sous gestion de configuration par git : 
    
    ```
    git add -A
    ```
    
    * mettre à jour le repo à chaque fois que nécessaire: 
    
    ```
    git commit -am "un message pour ce souvenir quoi"
    ```
    
    * une fois que vous pensez disposer d'une application testable ou déployable, poussez la vers StageOs :
    
    ```
    git push
    ```


|
|

    
    
Notre intelligence artificielle se lance alors et prend le relais.
    
Evidemment, dans le cas où vous travaillez directement sur noter Gillab en "manuel", un commit de votre projet sur la branche
master suffit pour déclencher notre IA.

Dans l'interface de votre projet sur StageOS, vous voyez alors le statut et l'historique
de toutes vos actions et l'état des processus (pipeline) correspondant.


|
|


Votre projet est immédiatement pris en compte, suivant la charge de nos systèmes
il peut rester en attente un très court moment :

```{r   pending, echo = FALSE, fig.cap = " En attente" }
img_from <- here::here("docs/images/pipeline_pending.PNG")
plot(as.raster(load.image(img_from)))

```

Puis le projet est en cours de traitement :

```{r   running, echo = FALSE, fig.cap = " En cours de traitement" }
img_from <- here::here("docs/images/pipeline_running.PNG")
plot(as.raster(load.image(img_from)))

```

Vous pouvez consulter l'état des pipelines qui mènent au tests ou au déploiement 
de votre application en _live_ en cliquant sur _Détail_ :


```{r   detail_running, echo = FALSE, fig.cap = " En cours de traitement" }
img_from <- here::here("docs/images/detail_running.PNG")
plot(as.raster(load.image(img_from)))

```

On distigue très facile un processus en échec d'un processus qui se passe bien :

```{r   failed_vs_running, echo = FALSE, fig.cap = " Un des processus a échoué" }
img_from <- here::here("docs/images/failed_vs_running.PNG")
plot(as.raster(load.image(img_from)))

```




# FAQ : Vos questions les plus fréquentes

## Quelles compétences pour utiliser StageOS ?

StageOS s'adresse aux développeurs sachant créer une application qui fonctionnent
sur leur poste de travail et qui désirent aller plus loin et n'ont soit pas la compétence
pour le faire, soit pas le temps, soit pas les outils installés pour le faire dans de
bonne conditions de performance et de fiabilité.

Ces développeurs doivent  se confronter au problème de construction, test et de  déploiement de leur application dans un contexte opérationnel et déployer des compétences
que l'on désigne souvent sous le terme "Devops". 

StageOs ne nécessite pas d'avoir de compétences Devops, mais une connaissance surfacique
de Git et des paradigmes de l'intégration et du déploiement continue d'application peut aider
à exploiter l'outil au mieux. Pour autant, en première approximation la simple lecture du tutorial
précédent démontre le peu de connaissance à mobiliser pour utiliser StageOS.


## Quels prérequis techniques pour utiliser StageOs ?

Pour utiliser StageOSIl faut : 

* une machine de développement connectée qui puisse accéder au site. 
* une application à tester ou déployer.
* de façon optionnelle : un dépôt Git sur sa machine ou sur un site déporté.


## En quoi l'intelligence artifielle de StageOs est-elle utile ?

La variété des cas de figure  et la constante évolution des "assets" informatiques en terme de dépendances logicielles, de "pipeline", d'options de configuration, de savoir-faire de création de
micro-services ou d'orchestration de "containers" impose la gestion  et la combinaison de nombreuses règles. La trés grande  combinatoire de l'interaction entre ces nombreuses régles et 
les nombreux évènements à gérer impose la mise en oeuvre de méthodes heuristiques d'une grande 
efficacité, très modulaire et performantes. C'est l'objet de l'IA non déterminisite 
que nous avons mis en place.





## Langages et produits disponibles

Vous pouvez travailler dans les contextes suivants :

* Python

  * outils de test
  * frameworks : Flask, Django
  * packages de machine learning : Tensorflow
  
* NodeJS

  * Outils de test 
  * Gestionnaires de package 
  
## Kubernetes

Suis-je obligé d'avoir un Kubernetes à disposition ?

Non, mais vous pouvez en souscrire un pour déployer en production automatiquement.

